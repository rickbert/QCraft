package industry;

import java.util.HashSet;
import java.util.Random;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import skills.Skill;
import skills.Skills;
import skills.SkillHandler;

public class Woodcutting extends Skill { 

	private enum Wood {
		OAK, BIRCH, SPRUCE, JUNGLE;
	}

	public Woodcutting(Player player, int level, int exp) {
		super(player, level, exp);
	}

	@Override
	public void info() {
		super.info();
		message(1, "Active: Fell a single tree up to  " + (int) (10 + level / 25) + " logs or " + (int) (10 + 3*level/20) + " jungle logs");
		message(250, "Passive: Increased chopping speed level " + (int) level/250 );
		message(250, "Level 250 Passive: Instant leave breaking");
		message(750, "Level 750 Passive: Extra apple and sapling drops");
	}

	public static void active(Player player, Block block) {
		int level = SkillHandler.getSkill(player, Skills.WOODCUTTING).level();
		if (block.getType().equals(Material.LEAVES)) {
			if (level >= 250) {
				block.breakNaturally();
			}
		}
	}
	
	public static boolean treeFeller(Player player, Block block) {
		HashSet<Block> tree = new HashSet<Block>();		
		tree = markTree(tree, block);
		Skill skill = SkillHandler.getSkill(player, Skills.WOODCUTTING);
		switch (tree.iterator().next().getData()) {
		case 0:
		case 1:
		case 2:
			if (tree.size() <= 10 + skill.level() / 25) {
				for (Block log : tree) {
					log.breakNaturally();
					skill.addExp(20);
				}
				player.sendMessage("...");
				return true;
			}
			else {
				player.sendMessage("Tree too big for Tree Feller!");
			}
			break;
		case 3:
			if (tree.size() <= 10 + skill.level() * 3 / 20) {
				for (Block log : tree) {
					log.breakNaturally();
					skill.addExp(10);
				}
				return true;
			}
			else {
				player.sendMessage("Tree too big for Tree Feller!");
			}
			break;
		default:
			break;			
		}
		return false;
	}
	
//	private static LinkedList<Block> markTrunk(LinkedList<Block> trunk) {
//		Block root = trunk.getFirst();
//		Block child = root.getRelative(0, 1, 0);
//		while (child.getType().equals(Material.LOG)) {
//			if (root.getData() == child.getData()) {
//				trunk.add(child);
//			}
//			child.getRelative(0, 1, 0);
//		}
//		
//		child = root.getRelative(0, -1, 0);
//		while (child.getType().equals(Material.LOG)) {
//			if (root.getData() == child.getData()) {
//				trunk.add(child);
//			}
//			child.getRelative(0, 1, 0);
//		}
//		
//		return trunk;
//	}
	
	private static HashSet<Block> markTree(HashSet<Block> tree, Block block) {
		if (block.getType().equals(Material.LOG) && !tree.contains(block)) {
			tree.add(block);
			for (int x = -1; x <= 1; x++) {
				for (int y = -1; y <= 1; y++) {
					for (int z = -1; z <= 1; z++) {
						markTree(tree, block.getRelative(x, y, z));
					}
				}
			}
		} 
		return tree;
	}

	public static void blockBreak(Player player, Block block) {
		Skill woodcutting = SkillHandler.getSkill(player, Skills.WOODCUTTING);
		if (block.getType().equals(Material.LOG)) {
			switch (getWoodType(block)) {
			case OAK:
			case SPRUCE:
			case BIRCH:
				woodcutting.addExp(20);
				break;
			case JUNGLE:
				woodcutting.addExp(10);
				break;
			}	
		}
	}

	public static boolean isLoggable(Block block) {
		return block.getType().equals(Material.LOG) || block.getType().equals(Material.LEAVES);
	}

	private static Wood getWoodType(Block block) {
		switch (block.getData()) {
		case 0:
		case 4:
		case 8:
		case 12:
		default:
			return Wood.OAK;
		case 1:
		case 5:
		case 9:
		case 13:
			return Wood.SPRUCE;
		case 2:
		case 6:
		case 10:
		case 14:
			return Wood.BIRCH;
		case 3:
		case 7:
		case 11:
		case 15:
			return Wood.JUNGLE;
		}
	}

	private static ItemStack getDrop(Player player, Block block) {
		int level = SkillHandler.getSkill(player, Skills.WOODCUTTING).level();
		double chance = new Random().nextDouble();
		if (level >= 750) {
			switch (block.getData()) {
			case 0:
				if (chance <= 0.005) {
					return new ItemStack(Material.APPLE);
				}
			case 1:
			case 2:
				if (chance <= 0.05) {
					return new ItemStack(Material.SAPLING, 1, block.getData());
				}
			case 3:
				if (chance <= 0.025) {
					return new ItemStack(Material.SAPLING, 1, block.getData());
				}
			}
		}
		return null;
	}
}