package combat;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.HashMap;

import javax.swing.Timer;

import org.bukkit.ChatColor;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;

import custom.Clock;

public class Resistance implements ActionListener {
	private static final PotionEffectType RESISTANCE = PotionEffectType.DAMAGE_RESISTANCE;
	private final LivingEntity target;
	private final Timer buffTimer, debuffTimer;
	private Clock buffClock, debuffClock, appleClock;
	private int buffStacks, debuffStacks, appleDuration;
	private static HashMap<LivingEntity, Resistance> resistances = new HashMap<LivingEntity, Resistance>();

	public Resistance(LivingEntity target) {
		this.target = target;

		buffStacks = 0;
		buffTimer = new Timer(10000, this);
		buffTimer.setRepeats(false);
		buffTimer.setActionCommand("buff");
		buffClock = new Clock();

		debuffStacks = 0;
		debuffTimer = new Timer(10000, this);
		debuffTimer.setRepeats(false);
		debuffTimer.setActionCommand("debuff");	
		debuffClock = new Clock();

		appleClock = new Clock();
		appleDuration = 0;

		resistances.put(target, this);
	}

	@Override
	public void actionPerformed(ActionEvent event) {
		switch (event.getActionCommand()) { //Check the action command to see if a buff/debuff is falling off. Ignore if null (refreshing effect)
		case "buff": //Buff has ended. Stop the buffClock and remove buffStacks
			buffTimer.stop();
			buffStacks = 0;
			if (target instanceof Player) {
				Player player = (Player) target;
				player.sendMessage(ChatColor.GREEN + "Buff Fell Off");
			}
			break;
		case "debuff": //Debuff has ended. Stop the debuffClock and remove debuffStacks
			debuffTimer.stop();
			debuffStacks = 0;
			if (target instanceof Player) {
				Player player = (Player) target;
				player.sendMessage(ChatColor.RED + "Debuff Fell Off");
			}
			break;
		default:
			break;
		}

		int amplifier = debuffStacks + buffStacks;

		if (appleDuration - appleClock.getTicks() > 0) { //Add 1 to amplifier if the target has an active god apple
			amplifier++;
		}

		if (target instanceof Player) {
			Player player = (Player) target;
			player.sendMessage("Rank " + amplifier);
		}
		
		switch (amplifier) { //Apply a potion effect depending on the amplifier
		case 2: //The target is either getting a buff for the full duration or getting whatever is left after the debuff wears off
		case 1: //The target gets either Resistance 1 (no active god apple) or Resistance 2 (active god apple)
			target.addPotionEffect(new PotionEffect(RESISTANCE, (int) (200 - buffClock.getTicks()), amplifier - 1));
			break;
		case 0: //Buff and debuff cancel each other out. Remove resistance effect
			target.removePotionEffect(RESISTANCE);
			break;
		default: //All other cases of amplifier (aka amplifier != 0, 1, or 2 --> amplifier is negative and so we need to debuff target
			target.addPotionEffect(new PotionEffect(RESISTANCE, 200, amplifier), true);
			break;
		}

		if (!buffTimer.isRunning() && !debuffTimer.isRunning()) { //If both the buff and debuff have worn off, remove this resistance instance
			if (appleDuration - appleClock.getTicks() > 0) { //Also check to see if we should reapply an active god apple
				PotionEffect effect = new PotionEffect(RESISTANCE, (int) (appleDuration - appleClock.getTicks()), 0);
				((Player) target).sendMessage("" + effect.getDuration());
				target.addPotionEffect(effect);
			}
			resistances.remove(target);
		}
	}

	private void checkForApple() { //Check for an active god apple.
		appleClock.reset();
		for(PotionEffect effect : target.getActivePotionEffects()) {
			if (effect.getType().equals(RESISTANCE)) {
				if (effect.getAmplifier() == 0) {
					if (effect.getDuration() > 200) {
						appleDuration = effect.getDuration();
					}
				}
			}
		}
	}

	private void debuff() { //Debuff the target. Always check for apple first and then restart the debuffClock and debuffTimer
		if (target instanceof Player) {
			Player player = (Player) target;
			player.sendMessage(ChatColor.RED + "Debuff");
		}
		checkForApple();
		debuffStacks--;
		debuffClock.reset();
		debuffTimer.restart();
		actionPerformed(new ActionEvent(this, 0, null));	
	}

	private void buff() { //Buff the target. Always check for apple first and then restart the buffClock and buffTimer
		if (target instanceof Player) {
			Player player = (Player) target;
			player.sendMessage(ChatColor.GREEN + "Buff");
		}
		checkForApple();
		buffStacks = 1; //Buff stacks cannot go above 1
		buffClock.reset();
		buffTimer.restart();
		actionPerformed(new ActionEvent(this, 0, null));
	}

	public static void debuff(LivingEntity target) {
		if (resistances.containsKey(target) == false) {
			resistances.put(target, new Resistance(target));
		}		
		resistances.get(target).debuff();
	}

	public static void buff(LivingEntity target) {
		if (resistances.containsKey(target) == false) {
			resistances.put(target, new Resistance(target));
		}
		resistances.get(target).buff();
	}
}
