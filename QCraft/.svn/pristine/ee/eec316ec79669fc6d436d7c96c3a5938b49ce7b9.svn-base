package actives;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.HashMap;

import javax.swing.Timer;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;

import custom.Clock;

public class Active implements ActionListener {
	private final Player player;
	private final Timer timer;
	private final Clock clock;
	private ActiveState activeState;
	private ActiveType activeType;
	private String activeName;
	private static HashMap<String, HashMap<ActiveType, Active>> actives = new HashMap<String, HashMap<ActiveType, Active>>();

	public enum ActiveState {
		READY, PRIMED, ACTIVE, COOLDOWN;
	}

	public enum ActiveType {
		ARCHAEOLOGY, FARMING, FISHING, MINING, SWORDS, TOUGHNESS, WOODCUTTING;
	}

	public Active(Player player, ActiveType activeType) {
		this.player = player;
		timer = new Timer(10000, this);
		timer.setRepeats(false);
		clock = new Clock();
		activeState = ActiveState.READY;
		this.activeType = activeType;
		for(ActiveType type : ActiveType.values()) {
			if (type.equals(activeType)) {
				String rawName = type.name().toLowerCase();
				rawName = rawName.substring(0, 1).toUpperCase() + rawName.substring(1);
				activeName = rawName + " Active";
			}			
		}
	}

	@Override
	public void actionPerformed(ActionEvent event) {
		timer.stop();
		switch (activeState) {
		case PRIMED:
			player.sendMessage(activeName + " cancelled!");
			actives.get(player.getName()).remove(activeType);
			break;
		case ACTIVE:
			timer.setInitialDelay(timer.getDelay());
			timer.restart();
			player.sendMessage(activeName + " ended!");
			activeState = ActiveState.COOLDOWN;
			break;
		case COOLDOWN:
			player.sendMessage(activeName + " ready!");
			actives.get(player.getName()).remove(activeType);
			break;
		default:
			break;
		}
	}

	private void prime(int primeDuration) {
		if (activeState.equals(ActiveState.READY)) {
			player.sendMessage(activeName + " primed");
			activeState = ActiveState.PRIMED;
			primeDuration = primeDuration * 1000;
			timer.setInitialDelay(primeDuration);
			timer.restart();
		}
		else {
			info();
		}
	}

	private void activate(int activeDuration, int cooldownDuration) {
		if (activeState.equals(ActiveState.PRIMED)) {
			player.sendMessage(activeName + " activated");
			activeState = ActiveState.ACTIVE;
			activeDuration = activeDuration * 1000;
			cooldownDuration = cooldownDuration * 1000;
			timer.setInitialDelay(activeDuration);
			timer.setDelay(cooldownDuration);
			timer.restart();
		}
		else {
			info();
		}
	}

	private ActiveState getState() {
		return activeState;
	}
	
	private long getTime() {
		return Math.round((timer.getInitialDelay() / 1000) - clock.getTime(Clock.SECONDS));
	}

	private void info() {
		switch (activeState) {
		case PRIMED:
			player.sendMessage(activeName + " currently primed");
			break;
		case ACTIVE:
			clock.reset();
			player.sendMessage(activeName + " currently active");
			break;
		case COOLDOWN:
			player.sendMessage(activeName + " on cooldown");
			break;
		default:
			break;
		}
	}

	public static void prime(String player, ActiveType activeType, int primeDuration) {
		if (!actives.containsKey(player)) {
			actives.put(player, new HashMap<ActiveType, Active>());
		}
		if (!actives.get(player).containsKey(activeType)) {
			actives.get(player).put(activeType, new Active(Bukkit.getPlayer(player), activeType));
		}

		actives.get(player).get(activeType).prime(primeDuration);
	}

	public static void activate(String player, ActiveType activeType, int activeDuration, int cooldownDuration) {
		if (!actives.containsKey(player)) {
			actives.put(player, new HashMap<ActiveType, Active>());
		}
		if (!actives.get(player).containsKey(activeType)) {
			actives.get(player).put(activeType, new Active(Bukkit.getPlayer(player), activeType));
		}
		actives.get(player).get(activeType).activate(activeDuration, cooldownDuration);
	}
	
	public static void reset(Player player) {
		if (actives.containsKey(player)) {
			actives.remove(player);
		}
	}

	public static ActiveState getState(String player, ActiveType activeType) {
		if (!actives.containsKey(player)) {
			actives.put(player, new HashMap<ActiveType, Active>());
		}
		if (!actives.get(player).containsKey(activeType)) {
			actives.get(player).put(activeType, new Active(Bukkit.getPlayer(player), activeType));
		}

		return actives.get(player).get(activeType).getState();
	}	
	
	public static long getTime(String player, ActiveType activeType) {
		if (!actives.containsKey(player)) {
			actives.put(player, new HashMap<ActiveType, Active>());
		}
		if (!actives.get(player).containsKey(activeType)) {
			actives.get(player).put(activeType, new Active(Bukkit.getPlayer(player), activeType));
		}

		return actives.get(player).get(activeType).getTime();
	}
}
